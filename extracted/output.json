[
  {
    "kind": "Datatype",
    "name": "lit",
    "statement": "lit =\n    IntLit int\n  | Char char\n  | StrLit string\n  | Word8 word8\n  | Word64 word64\n  | Float64 word64",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "opn",
    "statement": "opn = Plus | Minus | Times | Divide | Modulo",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "opb",
    "statement": "opb = Lt | Gt | Leq | Geq",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "opw",
    "statement": "opw = Andw | Orw | Xor | Add | Sub",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "shift",
    "statement": "shift = Lsl | Lsr | Asr | Ror",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "fp_cmp",
    "statement": "fp_cmp = FP_Less | FP_LessEqual | FP_Greater | FP_GreaterEqual | FP_Equal",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "fp_uop",
    "statement": "fp_uop = FP_Abs | FP_Neg | FP_Sqrt",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "fp_bop",
    "statement": "fp_bop = FP_Add | FP_Sub | FP_Mul | FP_Div",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "fp_top",
    "statement": "fp_top = FP_Fma",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "word_size",
    "statement": "word_size = W8 | W64",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "thunk_mode",
    "statement": "thunk_mode = Evaluated | NotEvaluated",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "thunk_op",
    "statement": "thunk_op =\n    AllocThunk thunk_mode\n  | UpdateThunk thunk_mode\n  | ForceThunk",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "op",
    "statement": "op =\n  (* Operations on integers *)\n    Opn opn\n  | Opb opb\n  (* Operations on words *)\n  | Opw word_size opw\n  | Shift word_size shift num\n  | Equality\n  (* FP operations *)\n  | FP_cmp fp_cmp\n  | FP_uop fp_uop\n  | FP_bop fp_bop\n  | FP_top fp_top\n  (* Floating-point <-> word translations *)\n  | FpFromWord\n  | FpToWord\n  (* Function application *)\n  | Opapp\n  (* Reference operations *)\n  | Opassign\n  | Opref\n  | Opderef\n  (* Word8Array operations *)\n  | Aw8alloc\n  | Aw8sub\n  | Aw8length\n  | Aw8update\n  (* Word/integer conversions *)\n  | WordFromInt word_size\n  | WordToInt word_size\n  (* string/bytearray conversions *)\n  | CopyStrStr\n  | CopyStrAw8\n  | CopyAw8Str\n  | CopyAw8Aw8\n  | XorAw8Str_unsafe\n  (* Char operations *)\n  | Ord\n  | Chr\n  | Chopb opb\n  (* String operations *)\n  | Implode\n  | Explode\n  | Strsub\n  | Strlen\n  | Strcat\n  (* Vector operations *)\n  | VfromList\n  | Vsub\n  | Vlength\n  (* Array operations *)\n  | Aalloc\n  | AallocEmpty\n  | AallocFixed\n  | Asub\n  | Alength\n  | Aupdate\n  (* Unsafe array accesses *)\n  | Asub_unsafe\n  | Aupdate_unsafe\n  | Aw8sub_unsafe\n  | Aw8update_unsafe\n  (* thunk operations *)\n  | ThunkOp thunk_op\n  (* List operations *)\n  | ListAppend\n  (* Configure the GC *)\n  | ConfigGC\n  (* Call a given foreign function *)\n  | FFI string\n  (* Evaluate new code in a given env *)\n  | Eval\n  (* Get the identifier of an env object *)\n  | Env_id",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "op_class",
    "statement": "op_class =\n    EvalOp (* Eval primitive *)\n  | FunApp (* function application *)\n  | Force (* forcing a thunk *)\n  | Simple (* arithmetic operation, no finite-precision/reals *)",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "lop",
    "statement": "lop = And | Or",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "ast_t",
    "statement": "ast_t =\n  (* Type variables that the user writes down ('a, 'b, etc.) *)\n    Atvar tvarN\n  (* Function type *)\n  | Atfun ast_t ast_t\n  (* Tuple type *)\n  | Attup (ast_t list)\n  (* Type constructor applications.\n    0-ary type applications represent unparameterised types (e.g., num or string) *)\n  | Atapp (ast_t list) ((modN, typeN) id)",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "pat",
    "statement": "pat =\n    Pany\n  | Pvar varN\n  | Plit lit\n  (* Constructor applications.\n     A Nothing constructor indicates a tuple pattern. *)\n  | Pcon (((modN, conN) id) option) (pat list)\n  | Pref pat\n  (* Pattern alias. *)\n  | Pas pat varN\n  | Ptannot pat ast_t",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "exp",
    "statement": "exp =\n    Raise exp\n  | Handle exp ((pat # exp) list)\n  | Lit lit\n  (* Constructor application.\n     A Nothing constructor indicates a tuple pattern. *)\n  | Con (((modN, conN)id)option) (exp list)\n  | Var ((modN, varN) id)\n  | Fun varN exp\n  (* Application a primitive operator to arguments.\n     Includes function application. *)\n  | App op (exp list)\n  (* Logical operations (and, or) *)\n  | Log lop exp exp\n  | If exp exp exp\n  (* Pattern matching *)\n  | Mat exp ((pat # exp) list)\n  (* A let expression\n     A Nothing value for the binding indicates that this is a\n     sequencing expression, that is: (e1; e2). *)\n  | Let (varN option) exp exp\n  (* Local definition (potentially) mutually recursive\n     functions.\n     The first varN is the function's name, and the second varN\n     is its parameter. *)\n  | Letrec ((varN # varN # exp) list) exp\n  | Tannot exp ast_t\n  (* Location annotated expressions, not expected in source programs *)\n  | Lannot exp locs",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "dec",
    "statement": "dec =\n  (* Top-level bindings\n   * The pattern allows several names to be bound at once *)\n    Dlet locs pat exp\n  (* Mutually recursive function definition *)\n  | Dletrec locs ((varN # varN # exp) list)\n  (* Type definition\n     Defines several data types, each which has several\n     named variants, which can in turn have several arguments.\n   *)\n  | Dtype locs type_def\n  (* Type abbreviations *)\n  | Dtabbrev locs (tvarN list) typeN ast_t\n  (* New exceptions *)\n  | Dexn locs conN (ast_t list)\n  (* Module *)\n  | Dmod modN (dec list)\n  (* Local: local part, visible part *)\n  | Dlocal (dec list) (dec list)\n  (* Store current lexical env in an env value *)\n  | Denv tvarN",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "id",
    "statement": "id = Short 'n | Long 'm id",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Datatype",
    "name": "namespace",
    "statement": "namespace =\n    Bind (('n,'v) alist) (('m,namespace) alist)",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "isFpBool_def",
    "statement": "isFpBool op = case op of FP_cmp _ => T | _ => F",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Definition",
    "name": "pat_bindings_def",
    "statement": "pat_bindings Pany already_bound = already_bound âˆ§\n  pat_bindings (Pvar n) already_bound = n::already_bound âˆ§\n  pat_bindings (Plit l) already_bound = already_bound âˆ§\n  pat_bindings (Pcon v0 ps) already_bound = pats_bindings ps already_bound âˆ§\n  pat_bindings (Pref p) already_bound = pat_bindings p already_bound âˆ§\n  pat_bindings (Pas p i) already_bound = pat_bindings p (i::already_bound) âˆ§\n  pat_bindings (Ptannot p v1) already_bound = pat_bindings p already_bound âˆ§\n  pats_bindings [] already_bound = already_bound âˆ§\n  pats_bindings (p::ps) already_bound =\n  pats_bindings ps (pat_bindings p already_bound)",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Definition",
    "name": "Seqs_def",
    "statement": "Seqs [] = Con NONE [] âˆ§\n  Seqs (x::xs) = Let NONE x (Seqs xs)",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Definition",
    "name": "Apps_def",
    "statement": "Apps f [] = f âˆ§\n  Apps f (x::xs) = Apps (App Opapp [f; x]) xs",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Definition",
    "name": "Funs_def",
    "statement": "Funs [] e = e âˆ§\n  Funs (x::xs) e = Fun x (Funs xs e)",
    "source_file": ".\\to_be_extracted\\astScript.sml"
  },
  {
    "kind": "Definition",
    "name": "alist_rel_restr_def",
    "statement": "(alist_rel_restr R l1 l2 [] â‡” T) âˆ§\n  (alist_rel_restr R l1 l2 (k1::keys) â‡”\n    case ALOOKUP l1 k1 of\n    | NONE => F\n    | SOME v1 =>\n      case ALOOKUP l2 k1 of\n      | NONE => F\n      | SOME v2 => R k1 v1 v2 âˆ§ alist_rel_restr R l1 l2 keys)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Definition",
    "name": "alistSub_def",
    "statement": "alistSub R e1 e2 â‡” alist_rel_restr R e1 e2 (MAP FST e1)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsSub_compute_def",
    "statement": "nsSub_compute path R (Bind e1V e1M) (Bind e2V e2M) â‡”\n    alistSub (\\k v1 v2. R (mk_id (REVERSE path) k) v1 v2) e1V e2V âˆ§\n    alistSub (\\k v1 v2. nsSub_compute (k::path) R v1 v2) e1M e2M\nTermination\n  wf_rel_tac `measure (\\(p,r,env,_). namespace_size (\\x.0) (\\x.0) (\\x.0) env)`\n >> rw []\n >> Induct_on `e1M`\n >> rw [namespace_size_def]\n >> PairCases_on `h`\n >> fs [ALOOKUP_def]\n >> every_case_tac\n >> fs []\n >> rw [namespace_size_def,basicSizeTheory.pair_size_def]",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Definition",
    "name": "mk_id_def",
    "statement": "mk_id [] n = Short n âˆ§\n  mk_id (mn::mns) n = Long mn (mk_id mns n)",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "id_to_n_def",
    "statement": "id_to_n (Short n) = n âˆ§\n id_to_n (Long _ id) = id_to_n id",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "id_to_mods_def",
    "statement": "id_to_mods (Short _) = [] âˆ§\n  id_to_mods (Long mn id) = mn::id_to_mods id",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsLookup_def",
    "statement": "nsLookup ((Bind v m):('m,'n,'v)namespace) (Short n) =\n    ALOOKUP v n âˆ§\n  nsLookup (Bind v m) (Long mn id) =\n    case ALOOKUP m mn of\n    | NONE => NONE\n    | SOME env => nsLookup env id",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsLookupMod_def",
    "statement": "nsLookupMod e [] = SOME (e:('m,'n,'v)namespace) âˆ§\n  nsLookupMod (Bind v m) (mn::path) =\n  case ALOOKUP m mn of NONE => NONE | SOME env => nsLookupMod env path",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsEmpty_def",
    "statement": "nsEmpty = Bind [] []",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsAppend_def",
    "statement": "nsAppend (Bind v1 m1) (Bind v2 m2) = Bind (v1 ++ v2) (m1 ++ m2)",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsLift_def",
    "statement": "nsLift mn env = Bind [] [(mn,env)]",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "alist_to_ns_def",
    "statement": "alist_to_ns a = Bind a []",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsBind_def",
    "statement": "nsBind k x (Bind v m) = Bind ((k,x)::v) m",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsBindList_def",
    "statement": "nsBindList l e = FOLDR (Î»(x,v) e. nsBind x v e) e l",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsOptBind_def",
    "statement": "nsOptBind n x env = case n of NONE => env | SOME n => nsBind n x env",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsSing_def",
    "statement": "nsSing n x = Bind [(n,x)] []",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsSub_def",
    "statement": "nsSub r env1 env2 â‡”\n     (âˆ€id v1.\n        nsLookup env1 id = SOME v1 â‡’\n        âˆƒv2. nsLookup env2 id = SOME v2 âˆ§ r id v1 v2) âˆ§\n     âˆ€path. nsLookupMod env2 path = NONE â‡’ nsLookupMod env1 path = NONE",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsAll_def",
    "statement": "nsAll f env â‡” âˆ€id v. nsLookup env id = SOME v â‡’ f id v",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsAll2_def",
    "statement": "nsAll2 r env1 env2 â‡”\n    nsSub r env1 env2 âˆ§ nsSub (Î»x y z. r x z y) env2 env1",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsDom_def",
    "statement": "nsDom (env:('m,'n,'v)namespace) =\n     {n | (v,n) | v âˆˆ ð•Œ(:Ï†) âˆ§ n âˆˆ ð•Œ(:(Î½, Î¾) id) âˆ§ nsLookup env n = SOME v}",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsDomMod_def",
    "statement": "nsDomMod (env:('m,'n,'v)namespace) =\n     {n | (v,n) | v âˆˆ ð•Œ(:(Î½, Î¾, Ï†) namespace) âˆ§ n âˆˆ ð•Œ(:Î½ list) âˆ§\n                  nsLookupMod env n = SOME v}",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Definition",
    "name": "nsMap_def",
    "statement": "nsMap (f:'v -> 'w) ((Bind v m):('m,'n,'v)namespace) =\n    Bind (MAP (Î»(n,x). (n,f x)) v) (MAP (Î»(mn,e). (mn,nsMap f e)) m)",
    "source_file": ".\\to_be_extracted\\namespaceScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "mk_id_surj",
    "statement": "!id. ?p n. id = mk_id p n",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "mk_id_thm",
    "statement": "!id. mk_id (id_to_mods id) (id_to_n id) = id",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_mono2",
    "statement": "(!x y z. nsLookup e1 x = SOME y âˆ§ nsLookup e2 x = SOME z âˆ§ R1 x y z â‡’ R2 x y z) â‡’ (nsSub R1 e1 e2 â‡’ nsSub R2 e1 e2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_Bind_v_some",
    "statement": "nsLookup (Bind v []) k = SOME x â‡”\n   âˆƒy. k = Short y âˆ§ ALOOKUP v y = SOME x",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_to_nsLookupMod",
    "statement": "!n v t.\n    nsLookup n v = SOME t\n    â‡’\n    ?m. nsLookupMod n (id_to_mods v) = SOME m âˆ§ nsLookup m (Short (id_to_n v)) = SOME t",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_alist_to_ns_some",
    "statement": "!l id v. nsLookup (alist_to_ns l) id = SOME v â‡” ?x'. id = Short x' âˆ§ ALOOKUP l x' = SOME v",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_alist_to_ns_none",
    "statement": "!l id. nsLookup (alist_to_ns l) id = NONE â‡” !x'. id = Short x' â‡’ ALOOKUP l x' = NONE",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_nsLift",
    "statement": "!mn e id.\n    nsLookup (nsLift mn e) id =\n    case id of\n    | Long mn' id' =>\n      if mn = mn' then\n        nsLookup e id'\n      else\n        NONE\n    | Short _ => NONE",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookupMod_nsLift",
    "statement": "!mn e path.\n    nsLookupMod (nsLift mn e) path =\n    case path of\n    | [] => SOME (nsLift mn e)\n    | (mn'::path') =>\n      if mn = mn' then\n        nsLookupMod e path'\n      else\n        NONE",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_nsAppend_none",
    "statement": "âˆ€e1 id e2.\n    nsLookup (nsAppend e1 e2) id = NONE\n    â‡”\n    (nsLookup e1 id = NONE âˆ§\n     (nsLookup e2 id = NONE âˆ¨\n      ?p1 p2 e3. p1 â‰  [] âˆ§ id_to_mods id = p1++p2 âˆ§ nsLookupMod e1 p1 = SOME e3))",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_nsAppend_some",
    "statement": "âˆ€e1 id e2 v.\n    nsLookup (nsAppend e1 e2) id = SOME v\n    â‡”\n    nsLookup e1 id = SOME v âˆ¨\n    (nsLookup e1 id = NONE âˆ§ nsLookup e2 id = SOME v âˆ§\n     !p1 p2. p1 â‰  [] âˆ§ id_to_mods id = p1++p2 â‡’ nsLookupMod e1 p1 = NONE)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAppend_to_nsBindList",
    "statement": "!l. nsAppend (alist_to_ns l) e = nsBindList l e",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookupMod_nsAppend_none",
    "statement": "!e1 e2 path.\n    nsLookupMod (nsAppend e1 e2) path = NONE\n    â‡”\n    (nsLookupMod e1 path = NONE âˆ§\n     (nsLookupMod e2 path = NONE âˆ¨\n      ?p1 p2 e3. p1 â‰  [] âˆ§ path = p1++p2 âˆ§ nsLookupMod e1 p1 = SOME e3))",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookupMod_nsAppend_some",
    "statement": "!e1 e2 path.\n    (nsLookupMod (nsAppend e1 e2) path = SOME x\n     â‡”\n     if path = [] then x = nsAppend e1 e2 else\n     nsLookupMod e1 path = SOME x âˆ¨\n      (nsLookupMod e2 path = SOME x âˆ§\n      !p1 p2. p1 â‰  [] âˆ§ path = p1++p2 â‡’ nsLookupMod e1 p1 = NONE))",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_nsAll",
    "statement": "!env x P v. nsAll P env âˆ§ nsLookup env x = SOME v â‡’ P x v",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll_nsAppend",
    "statement": "!f e1 e2. nsAll f e1 âˆ§ nsAll f e2 â‡’ nsAll f (nsAppend e1 e2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll_nsBind",
    "statement": "!P x v e. P (Short x) v âˆ§ nsAll P e â‡’ nsAll P (nsBind x v e)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll_nsOptBind",
    "statement": "!P x v e. (x = NONE âˆ¨ ?n. x = SOME n âˆ§ P (Short n) v) âˆ§ nsAll P e â‡’ nsAll P (nsOptBind x v e)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll_alist_to_ns",
    "statement": "!R l. EVERY (Î»(n,v). R (Short n) v) l â‡’ nsAll R (alist_to_ns l)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll_nsAppend_left",
    "statement": "!P n1 n2. nsAll P (nsAppend n1 n2) â‡’ nsAll P n1",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_conj",
    "statement": "!P Q e1 e2. nsSub (\\id x y. P id x y âˆ§ Q id x y) e1 e2 â‡” nsSub P e1 e2 âˆ§\n  nsSub Q e1 e2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_refl",
    "statement": "!P R. (!n x. P n x â‡’ R n x x) â‡’ !e. nsAll P e â‡’ nsSub R e e",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_nsBind",
    "statement": "!R x v1 v2 e1 e2.\n     R (Short x) v1 v2 âˆ§ nsSub R e1 e2 â‡’ nsSub R (nsBind x v1 e1) (nsBind x v2 e2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_nsAppend2",
    "statement": "!R e1 e2 e2'. nsSub R e1 e1 âˆ§ nsSub R e2 e2' â‡’ nsSub R (nsAppend e1 e2) (nsAppend e1 e2')",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_nsAppend_lift",
    "statement": "!R mn e1 e1' e2 e2'.\n    nsSub (\\id. R (Long mn id)) e1 e1' âˆ§\n    nsSub R e2 e2'\n    â‡’\n    nsSub R (nsAppend (nsLift mn e1) e2) (nsAppend (nsLift mn e1') e2')",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "alist_rel_restr_thm",
    "statement": "!R e1 e2 keys.\n    alist_rel_restr R e1 e2 keys â‡”\n      !k. MEM k keys â‡’ ?v1 v2. ALOOKUP e1 k = SOME v1 âˆ§ ALOOKUP e2 k = SOME v2 âˆ§ R k v1 v2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "alistSub_cong",
    "statement": "!l1 l2 l1' l2' R R'.\n    l1 = l1' âˆ§ l2 = l2' âˆ§ (!n x y. ALOOKUP l1' n = SOME x âˆ§ ALOOKUP l2' n = SOME y â‡’ R n x y = R' n x y) â‡’\n    (alistSub R l1 l2 â‡” alistSub R' l1' l2')",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_FOLDR_nsLift",
    "statement": "!e p k. nsLookup (FOLDR nsLift e p) (mk_id p k) = nsLookup e (Short k)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_FOLDR_nsLift_some",
    "statement": "!e p id v.\n    nsLookup (FOLDR nsLift e p) id = SOME v â‡”\n    (p = [] âˆ§ nsLookup e id = SOME v) âˆ¨\n    (p â‰  [] âˆ§ ?p2 n. id = mk_id (p++p2) n âˆ§ nsLookup e (mk_id p2 n) = SOME v)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookupMod_FOLDR_nsLift_none",
    "statement": "!e p1 p2. nsLookupMod (FOLDR nsLift e p1) p2 = NONE â‡”\n    (IS_PREFIX p1 p2 âˆ¨ IS_PREFIX p2 p1) â‡’\n    ?p3. p2 = p1++p3 âˆ§ nsLookupMod e p3 = NONE",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_compute_thm_general",
    "statement": "!p R e1 e2.\n    nsSub R (FOLDR nsLift e1 (REVERSE p)) (FOLDR nsLift e2 (REVERSE p)) â‡”\n    nsSub_compute p R e1 e2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_compute_thm",
    "statement": "!R e1 e2. nsSub R e1 e2 â‡” nsSub_compute [] R e1 e2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_conj",
    "statement": "!P Q e1 e2. nsAll2 (\\id x y. P id x y âˆ§ Q id x y) e1 e2 â‡” nsAll2 P e1 e2 âˆ§ nsAll2 Q e1 e2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_nsLookup1",
    "statement": "!R e1 e2 n v1.\n    nsLookup e1 n = SOME v1 âˆ§\n    nsAll2 R e1 e2\n    â‡’\n    ?v2. nsLookup e2 n = SOME v2 âˆ§ R n v1 v2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_nsLookup2",
    "statement": "!R e1 e2 n v2.\n    nsLookup e2 n = SOME v2 âˆ§\n    nsAll2 R e1 e2\n    â‡’\n    ?v1. nsLookup e1 n = SOME v1 âˆ§ R n v1 v2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_nsLookup_none",
    "statement": "!R e1 e2 n.\n    nsAll2 R e1 e2\n    â‡’\n    (nsLookup e1 n = NONE â‡” nsLookup e2 n = NONE)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_nsBind",
    "statement": "!R x v1 v2 e1 e2.\n     R (Short x) v1 v2 âˆ§ nsAll2 R e1 e2 â‡’ nsAll2 R (nsBind x v1 e1) (nsBind x v2 e2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_nsBindList",
    "statement": "!R l1 l2 e1 e2.\n     LIST_REL (\\(x,y) (x',y'). x = x' âˆ§ R (Short x) y y') l1 l2 âˆ§ nsAll2 R e1 e2\n     â‡’\n     nsAll2 R (nsBindList l1 e1) (nsBindList l2 e2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_nsAppend",
    "statement": "!R e1 e1' e2 e2'.\n    nsAll2 R e1 e2 âˆ§ nsAll2 R e1' e2' â‡’ nsAll2 R (nsAppend e1 e1') (nsAppend e2 e2')",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll2_alist_to_ns",
    "statement": "!R l1 l2. LIST_REL (\\(x,y) (x',y'). x = x' âˆ§ R (Short x) y y') l1 l2 â‡’ nsAll2 R (alist_to_ns l1) (alist_to_ns l2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsMap_compose",
    "statement": "âˆ€g e f. nsMap f (nsMap g e) = nsMap (f o g) e",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsMap_nsAppend",
    "statement": "!n1 n2 f. nsMap f (nsAppend n1 n2) = nsAppend (nsMap f n1) (nsMap f n2)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookupMod_nsMap",
    "statement": "!n x f. nsLookupMod (nsMap f n) x = OPTION_MAP (nsMap f) (nsLookupMod n x)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_nsMap",
    "statement": "!n x f. nsLookup (nsMap f n) x = OPTION_MAP f (nsLookup n x)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsAll_nsMap",
    "statement": "!f n P. nsAll P (nsMap f n) â‡” nsAll (\\x y. P x (f y)) n",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLift_nsMap",
    "statement": "!f n mn. nsLift mn (nsMap f n) = nsMap f (nsLift mn n)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsSub_nsMap",
    "statement": "!R f n1 n2.\n    nsSub R (nsMap f n1) (nsMap f n2) â‡” nsSub (\\id x y. R id (f x) (f y)) n1 n2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsLookup_nsDom",
    "statement": "!x n. x âˆˆ nsDom n â‡” ?v. nsLookup n x = SOME v",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsDom_nsAppend_equal",
    "statement": "!n1 n2 n3 n4.\n    nsDom n1 = nsDom n3 âˆ§\n    nsDom n2 = nsDom n4 âˆ§\n    nsDomMod n1 = nsDomMod n3 âˆ§\n    nsDomMod n2 = nsDomMod n4\n    â‡’\n    nsDom (nsAppend n1 n2) = nsDom (nsAppend n3 n4) âˆ§\n    nsDomMod (nsAppend n1 n2) = nsDomMod (nsAppend n3 n4)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsDom_nsLift",
    "statement": "!mn n. nsDom (nsLift mn n) = IMAGE (Long mn) (nsDom n)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsDomMod_nsLift",
    "statement": "!mn n. nsDomMod (nsLift mn n) = [] INSERT IMAGE (CONS mn) (nsDomMod n)",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsDom_nsAppend_flat",
    "statement": "!n1 n2.nsDomMod n1 = {[]} â‡’ nsDom (nsAppend n1 n2) = nsDom n1 âˆª nsDom n2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  },
  {
    "kind": "Theorem",
    "name": "nsDomMod_nsAppend_flat",
    "statement": "!n1 n2.nsDomMod n1 = {[]} â‡’ nsDomMod (nsAppend n1 n2) = nsDomMod n2",
    "source_file": ".\\to_be_extracted\\namespacePropsScript.sml"
  }
]